defmodule ScenicMcp.Server do
  use GenServer
  require Logger

  def start_link(opts) do
    port = Keyword.get(opts, :port, 9999)
    GenServer.start_link(__MODULE__, port, name: __MODULE__)
  end

  def init(port) do
    case :gen_tcp.listen(port, [:binary, packet: :line, active: false, reuseaddr: true]) do
      {:ok, listen_socket} ->
        Logger.info("ScenicMCP TCP server listening on port #{port}")
        {:ok, %{listen_socket: listen_socket, port: port}, {:continue, :accept}}
      
      {:error, reason} ->
        Logger.error("Failed to start TCP server on port #{port}: #{inspect(reason)}")
        {:stop, reason}
    end
  end

  def handle_continue(:accept, %{listen_socket: listen_socket} = state) do
    case :gen_tcp.accept(listen_socket) do
      {:ok, client} ->
        Logger.info("Client connected to ScenicMCP")
        {:noreply, Map.put(state, :client, client), {:continue, :loop}}
      
      {:error, reason} ->
        Logger.error("Failed to accept connection: #{inspect(reason)}")
        {:noreply, state, {:continue, :accept}}
    end
  end

  def handle_continue(:loop, %{client: client} = state) do
    case :gen_tcp.recv(client, 0) do
      {:ok, data} ->
        Logger.debug("Received: #{inspect(data)}")
        
        # Parse the incoming data
        response = handle_command(String.trim(data))
        
        json_response = Jason.encode!(response) <> "\n"
        :gen_tcp.send(client, json_response)
        
        {:noreply, state, {:continue, :loop}}
        
      {:error, :closed} ->
        Logger.info("Client disconnected")
        {:noreply, Map.delete(state, :client), {:continue, :accept}}
        
      {:error, reason} ->
        Logger.error("Error receiving data: #{inspect(reason)}")
        :gen_tcp.close(client)
        {:noreply, Map.delete(state, :client), {:continue, :accept}}
    end
  end

  def handle_info(msg, state) do
    Logger.debug("Unexpected message: #{inspect(msg)}")
    {:noreply, state}
  end

  # Handle different commands
  defp handle_command("hello") do
    %{
      message: "Hello from ScenicMCP!",
      node: Node.self(),
      time: DateTime.utc_now() |> DateTime.to_iso8601(),
      elixir_version: System.version(),
      otp_release: :erlang.system_info(:otp_release) |> List.to_string(),
      scenic_viewports: list_scenic_viewports()
    }
  end

  defp handle_command(json_string) do
    case Jason.decode(json_string) do
      {:ok, %{"action" => "status"}} ->
        handle_status()
      
      {:ok, %{"action" => "send_keys"} = command} ->
        handle_send_keys(command)
      
      {:ok, %{"action" => "send_mouse_move"} = command} ->
        handle_mouse_move(command)
      
      {:ok, %{"action" => "send_mouse_click"} = command} ->
        handle_mouse_click(command)
      
      {:ok, %{"action" => "get_scenic_graph"} = command} ->
        handle_get_scenic_graph(command)
      
      {:ok, command} ->
        %{error: "Unknown command", command: command}
      
      {:error, _} ->
        # Fallback to hello response for non-JSON
        handle_command("hello")
    end
  end

  defp handle_status do
    %{
      status: "active",
      scenic_viewports: list_scenic_viewports(),
      available_commands: ["send_keys", "send_mouse_move", "send_mouse_click", "get_scenic_graph"],
      time: DateTime.utc_now() |> DateTime.to_iso8601()
    }
  end

  defp handle_get_scenic_graph(%{"detail_level" => detail_level}) do
    handle_get_scenic_graph_with_level(detail_level)
  end

  defp handle_get_scenic_graph(_) do
    handle_get_scenic_graph_with_level("summary")
  end

  defp handle_get_scenic_graph_with_level(detail_level) do
    viewport = find_scenic_viewport()
    
    if viewport do
      try do
        # Try multiple approaches to get visual information
        
        # 1. Try Flamelex's own introspection if available
        flamelex_description = try_flamelex_introspection()
        
        # 2. Try to get script data from ETS tables
        script_data = get_script_data_from_ets()
        
        # 3. Try to get viewport state directly
        viewport_state = get_viewport_state(viewport)
        
        # 4. Try to analyze the viewport's script table directly
        viewport_scripts = analyze_viewport_scripts(viewport)
        
        description = if flamelex_description do
          # Use Flamelex-specific description if available
          case detail_level do
            "detailed" -> build_detailed_flamelex_description(flamelex_description, script_data, viewport_state, viewport_scripts)
            _ -> build_summary_flamelex_description(flamelex_description, script_data, viewport_state, viewport_scripts)
          end
        else
          # Fall back to generic Scenic description
          scene_info = get_scene_info_from_viewport(viewport)
          case detail_level do
            "detailed" -> build_detailed_description(scene_info, viewport, script_data, viewport_state)
            _ -> build_summary_description(scene_info, viewport, script_data, viewport_state)
          end
        end
        
        %{
          status: "ok",
          description: description,
          viewport: inspect(viewport),
          detail_level: detail_level
        }
      rescue
        e ->
          Logger.error("Error getting scenic graph: #{inspect(e)}")
          %{
            error: "Failed to get scenic graph",
            details: inspect(e),
            viewport: inspect(viewport)
          }
      end
    else
      %{error: "No Scenic viewport found", available_viewports: list_scenic_viewports()}
    end
  end

  defp get_scene_info_from_viewport(viewport_pid) do
    # Get basic viewport info
    viewport_info = case Process.info(viewport_pid, [:registered_name, :dictionary]) do
      [{:registered_name, name}, {:dictionary, dict}] ->
        %{
          viewport_name: name,
          viewport_pid: viewport_pid,
          dictionary: dict
        }
      _ ->
        %{
          viewport_pid: viewport_pid
        }
    end
    
    # Find scenes and get their graphs
    scenes = find_scenes_in_viewport(viewport_pid)
    scene_graphs = get_graphs_from_scenes(scenes)
    
    Map.merge(viewport_info, %{
      scenes: scenes,
      scene_graphs: scene_graphs
    })
  end
  
  defp get_graphs_from_scenes(scenes) do
    scenes
    |> Enum.map(fn %{pid: pid, info: info} ->
      try do
        case GenServer.call(pid, :get_graph, 5000) do
          {:ok, graph_info} -> 
            %{
              pid: pid,
              info: info,
              graph: graph_info
            }
          _ -> 
            # Fallback: get basic process info
            basic_info = get_basic_scene_info(pid)
            %{
              pid: pid,
              info: info,
              basic_info: basic_info,
              error: "Failed to get graph"
            }
        end
      catch
        :exit, _ -> 
          # Fallback: get basic process info
          basic_info = get_basic_scene_info(pid)
          %{
            pid: pid,
            info: info,
            basic_info: basic_info,
            error: "Scene timeout or not responding"
          }
      end
    end)
  end
  
  # Get basic information about a scene process without calling it
  defp get_basic_scene_info(pid) do
    try do
      case Process.info(pid, [:registered_name, :dictionary, :initial_call, :current_function]) do
        info when is_list(info) ->
          %{
            registered_name: Keyword.get(info, :registered_name),
            initial_call: Keyword.get(info, :initial_call),
            current_function: Keyword.get(info, :current_function),
            dictionary_keys: case Keyword.get(info, :dictionary) do
              dict when is_list(dict) -> Enum.map(dict, fn {k, _} -> k end)
              _ -> []
            end
          }
        _ -> %{error: "Could not get process info"}
      end
    rescue
      _ -> %{error: "Process info failed"}
    end
  end

  defp find_scenes_in_viewport(viewport_pid) do
    # Query the viewport directly for its scene information
    # The ViewPort tracks scenes in its internal state
    try do
      # Use GenServer.call to get the viewport's internal scene information
      case GenServer.call(viewport_pid, :query_info, 5000) do
        {:ok, %{pid: ^viewport_pid}} ->
          # Get scene information by calling the viewport's internal state
          # We need to find a way to access the scenes_by_pid map
          find_scenes_via_process_inspection(viewport_pid)
        
        _ ->
          Logger.warning("Could not query viewport info")
          []
      end
    rescue
      e ->
        Logger.error("Error querying viewport: #{inspect(e)}")
        []
    catch
      :exit, reason ->
        Logger.error("Viewport call failed: #{inspect(reason)}")
        []
    end
  end
  
  # Alternative approach: look for processes that implement Scenic.Scene behavior
  defp find_scenes_via_process_inspection(_viewport_pid) do
    Process.list()
    |> Enum.filter(&is_scene_process?/1)
    |> Enum.map(fn pid ->
      info = Process.info(pid, [:registered_name, :dictionary, :initial_call])
      %{pid: pid, info: info}
    end)
  end
  
  # Check if a process is actually a scene (not a supervisor)
  defp is_scene_process?(pid) do
    try do
      # First check if it's NOT a supervisor by looking at its initial call
      case Process.info(pid, [:initial_call, :registered_name]) do
        [{:initial_call, {:supervisor, _, _}}, _] -> 
          false  # It's a supervisor, skip it
        [{:initial_call, {Scenic.Scene.Supervisor, _, _}}, _] -> 
          false  # It's a Scenic supervisor, skip it
        _ ->
          # Now check if it looks like a scene process
          case Process.info(pid, :dictionary) do
            {:dictionary, dict} ->
              # Look for scene-specific keys in the process dictionary
              Enum.any?(dict, fn
                {"$initial_call", {Scenic.Scene, _, _}} -> true
                {:scene_module, _} -> true
                {:scene_state, _} -> true
                _ -> false
              end)
            _ -> false
          end
      end
    rescue
      _ -> false
    end
  end
  
  # Check if a scene has meaningful graph data
  defp scene_has_graph_data?(%{graph: graph}) when not is_nil(graph), do: true
  defp scene_has_graph_data?(%{graphs: graphs}) when not is_nil(graphs), do: true
  defp scene_has_graph_data?(_), do: false
  
  # NEW: Get script data from ETS tables
  defp get_script_data_from_ets do
    try do
      # Get the viewport
      viewport = find_scenic_viewport()
      
      if viewport do
        # Get the viewport's state
        state = :sys.get_state(viewport, 5000)
        
        # Extract the script table reference from the state
        case Map.get(state, :script_table) do
          nil ->
            Logger.warn("No script_table found in viewport state")
            %{error: "No script table in viewport state"}
            
          script_table_ref ->
            # Read all scripts from the table
            scripts = :ets.tab2list(script_table_ref)
            Logger.info("Script table has #{length(scripts)} entries")
            
            %{
              table_name: :viewport_script_table,
              table_ref: inspect(script_table_ref),
              script_count: length(scripts),
              scripts: Enum.map(scripts, fn entry ->
                case entry do
                  {name, operations, owner} when is_list(operations) ->
                    Logger.debug("Script entry: name=#{inspect(name)}, ops=#{length(operations)}")
                    %{
                      name: name,
                      owner: owner,
                      script_preview: inspect_script_operations(operations)
                    }
                  other ->
                    Logger.warn("Unexpected script entry format: #{inspect(other)}")
                    %{error: "Unexpected format", data: inspect(other)}
                end
              end)
            }
        end
      else
        Logger.error("No viewport found")
        %{error: "No viewport found"}
      end
    rescue
      e ->
        Logger.error("Error reading script data: #{inspect(e)}")
        Logger.error("Stack trace: #{inspect(__STACKTRACE__)}")
        %{error: "Failed to read script data", details: inspect(e)}
    end
  end
  
  # Try to find script table by examining content
  defp find_script_table_by_content(tables) do
    script_table = Enum.find(tables, fn table ->
      try do
        # Check if this looks like a script table
        case :ets.first(table) do
          :"$end_of_table" -> false
          key ->
            case :ets.lookup(table, key) do
              [{_, data, _}] when is_list(data) ->
                # Check if data looks like a compiled script
                is_script_data?(data)
              _ -> false
            end
        end
      rescue
        _ -> false
      end
    end)
    
    case script_table do
      nil -> 
        %{error: "No script table found"}
      table ->
        scripts = :ets.tab2list(table)
        %{
          table_name: :unknown,
          table_id: table,
          script_count: length(scripts),
          scripts: Enum.map(scripts, fn {name, script, owner} ->
            %{
              name: name,
              owner: owner,
              script_preview: inspect_script(script)
            }
          end)
        }
    end
  end
  
  # Check if data looks like a Scenic script
  defp is_script_data?(data) when is_list(data) do
    # Scenic scripts are lists of drawing commands
    Enum.any?(data, fn
      {:draw_text, _, _, _} -> true
      {:draw_rect, _, _, _, _} -> true
      {:draw_rrect, _, _, _, _, _} -> true
      {:draw_circle, _, _, _} -> true
      {:draw_ellipse, _, _, _, _} -> true
      {:draw_line, _, _, _, _} -> true
      {:draw_triangle, _, _, _, _} -> true
      {:draw_quad, _, _, _, _, _} -> true
      {:draw_sprites, _, _} -> true
      {:draw_script, _, _} -> true
      {:push_state} -> true
      {:pop_state} -> true
      {:pop_push_state} -> true
      _ -> false
    end)
  end
  defp is_script_data?(_), do: false
  
  # Inspect a script and provide a human-readable preview
  defp inspect_script(script) when is_binary(script) do
    # Script is compiled binary, decode it first
    analyze_compiled_script(script)
  end
  defp inspect_script(script) when is_list(script) do
    # Script is already decoded
    commands = Enum.take(script, 10)
    |> Enum.map(&inspect_script_command/1)
    |> Enum.join("\n")
    
    if length(script) > 10 do
      commands <> "\n... and #{length(script) - 10} more commands"
    else
      commands
    end
  end
  defp inspect_script(_), do: "Invalid script format"
  
  # Inspect already-decoded script operations
  defp inspect_script_operations(operations) when is_list(operations) do
    # Group operations by type for better summary
    elements = operations
    |> Enum.reduce(%{texts: [], shapes: [], colors: [], scripts: []}, fn op, acc ->
      case op do
        {:draw_text, text} ->
          %{acc | texts: [text | acc.texts]}
        {:draw_rect, _} ->
          %{acc | shapes: ["rectangle" | acc.shapes]}
        {:draw_rrect, _} ->
          %{acc | shapes: ["rounded rectangle" | acc.shapes]}
        {:draw_circle, _} ->
          %{acc | shapes: ["circle" | acc.shapes]}
        {:draw_triangle, _} ->
          %{acc | shapes: ["triangle" | acc.shapes]}
        {:fill_color, {:color_rgba, {r, g, b, _}}} ->
          color_name = describe_color(r, g, b)
          %{acc | colors: [color_name | acc.colors]}
        {:script, name} ->
          %{acc | scripts: [name | acc.scripts]}
        _ ->
          acc
      end
    end)
    
    # Build description
    parts = []
    
    parts = if length(elements.texts) > 0 do
      texts = elements.texts |> Enum.reverse() |> Enum.uniq() |> Enum.take(3)
      parts ++ ["Text: #{Enum.join(texts, ", ")}"]
    else
      parts
    end
    
    parts = if length(elements.shapes) > 0 do
      shapes = elements.shapes |> Enum.frequencies() |> Enum.map(fn {shape, count} ->
        if count > 1, do: "#{count} #{shape}s", else: shape
      end)
      parts ++ ["Shapes: #{Enum.join(shapes, ", ")}"]
    else
      parts
    end
    
    parts = if length(elements.colors) > 0 do
      colors = elements.colors |> Enum.uniq() |> Enum.take(3)
      parts ++ ["Colors: #{Enum.join(colors, ", ")}"]
    else
      parts
    end
    
    parts = if length(elements.scripts) > 0 do
      parts ++ ["Includes #{length(elements.scripts)} sub-scripts"]
    else
      parts
    end
    
    if length(parts) > 0 do
      Enum.join(parts, " | ")
    else
      "#{length(operations)} drawing operations"
    end
  end
  defp inspect_script_operations(_), do: "Invalid operations"
  
  # Describe a color based on RGB values
  defp describe_color(r, g, b) do
    cond do
      r == 0 && g == 0 && b == 0 -> "black"
      r == 255 && g == 255 && b == 255 -> "white"
      r > 200 && g > 200 && b > 200 -> "light gray"
      r < 50 && g < 50 && b < 50 -> "dark gray"
      r > 200 && g < 100 && b < 100 -> "red"
      r < 100 && g > 200 && b < 100 -> "green"
      r < 100 && g < 100 && b > 200 -> "blue"
      r > 200 && g > 200 && b < 100 -> "yellow"
      r > 200 && g < 100 && b > 200 -> "magenta"
      r < 100 && g > 200 && b > 200 -> "cyan"
      r > 200 && g > 100 && b < 50 -> "orange"
      r > 100 && g < 100 && b > 100 -> "purple"
      true -> "rgb(#{r},#{g},#{b})"
    end
  end
  
  # Convert script commands to human-readable format
  defp inspect_script_command({:draw_text, text, x, y}) do
    "  Text: \"#{text}\" at (#{x}, #{y})"
  end
  defp inspect_script_command({:draw_rect, x, y, w, h}) do
    "  Rectangle at (#{x}, #{y}) size #{w}x#{h}"
  end
  defp inspect_script_command({:draw_rrect, x, y, w, h, r}) do
    "  Rounded Rectangle at (#{x}, #{y}) size #{w}x#{h} radius #{r}"
  end
  defp inspect_script_command({:draw_circle, x, y, r}) do
    "  Circle at (#{x}, #{y}) radius #{r}"
  end
  defp inspect_script_command({:draw_line, x1, y1, x2, y2}) do
    "  Line from (#{x1}, #{y1}) to (#{x2}, #{y2})"
  end
  defp inspect_script_command({:draw_script, id, _}) do
    "  Include script: #{inspect(id)}"
  end
  defp inspect_script_command({:push_state}) do
    "  Push graphics state"
  end
  defp inspect_script_command({:pop_state}) do
    "  Pop graphics state"
  end
  defp inspect_script_command(cmd) do
    "  #{inspect(cmd)}"
  end
  
  # NEW: Try to get viewport state directly
  defp get_viewport_state(viewport_pid) do
    try do
      # Try to get the viewport's state
      case :sys.get_state(viewport_pid, 5000) do
        state when is_map(state) ->
          # Extract relevant information from the state
          %{
            has_state: true,
            state_keys: Map.keys(state),
            scripts: extract_scripts_from_state(state),
            scenes: extract_scenes_from_state(state)
          }
        _ ->
          %{has_state: false, error: "State is not a map"}
      end
    rescue
      e ->
        Logger.error("Error getting viewport state: #{inspect(e)}")
        %{has_state: false, error: inspect(e)}
    end
  end
  
  defp extract_scripts_from_state(state) do
    # Look for script-related fields in the state
    cond do
      Map.has_key?(state, :scripts) -> Map.get(state, :scripts)
      Map.has_key?(state, :script_table) -> Map.get(state, :script_table)
      Map.has_key?(state, :compiled_scripts) -> Map.get(state, :compiled_scripts)
      true -> nil
    end
  end
  
  defp extract_scenes_from_state(state) do
    # Look for scene-related fields in the state
    cond do
      Map.has_key?(state, :scenes_by_pid) -> Map.get(state, :scenes_by_pid)
      Map.has_key?(state, :scenes) -> Map.get(state, :scenes)
      Map.has_key?(state, :active_scenes) -> Map.get(state, :active_scenes)
      true -> nil
    end
  end
  
  # Try to use Flamelex's own introspection API
  defp try_flamelex_introspection do
    try do
      # Check if Flamelex introspection modules are available
      if Code.ensure_loaded?(Flamelex.API.GUIIntrospector) do
        %{
          scene_description: Flamelex.API.GUIIntrospector.describe_current_scene(),
          script_summary: Flamelex.API.GUIIntrospector.get_latest_script_summary(),
          script_stats: if(Code.ensure_loaded?(Flamelex.API.ScriptAnalysis), do: Flamelex.API.ScriptAnalysis.get_stats(), else: nil)
        }
      else
        nil
      end
    rescue
      _ -> nil
    end
  end
  
  # Analyze the viewport's script table directly
  defp analyze_viewport_scripts(viewport_pid) do
    try do
      # Get viewport info to find the script table reference
      case Process.info(viewport_pid, [:dictionary]) do
        [{:dictionary, dict}] ->
          # Look for script table reference in the dictionary
          script_table_ref = Enum.find_value(dict, fn
            {:script_table, ref} -> ref
            {"script_table", ref} -> ref
            _ -> nil
          end)
          
          if script_table_ref do
            analyze_script_table(script_table_ref)
          else
            # Try to find it in the viewport state
            case :sys.get_state(viewport_pid, 1000) do
              %{script_table: ref} -> analyze_script_table(ref)
              _ -> nil
            end
          end
          
        _ -> nil
      end
    rescue
      _ -> nil
    end
  end
  
  defp analyze_script_table(table_ref) do
    try do
      # Read all scripts from the table
      scripts = :ets.tab2list(table_ref)
      
      %{
        script_count: length(scripts),
        scripts: Enum.map(scripts, fn {id, compiled, _pid} ->
          %{
            id: id,
            size: byte_size(compiled),
            preview: analyze_compiled_script(compiled)
          }
        end)
      }
    rescue
      _ -> nil
    end
  end
  
  defp analyze_compiled_script(compiled) when is_binary(compiled) do
    # Decode the compiled script using Scenic's deserialize function
    try do
      case Scenic.Script.deserialize(compiled) do
        ops when is_list(ops) ->
          # Analyze the decoded operations
          analyze_script_operations(ops)
        _ ->
          "Failed to deserialize script"
      end
    rescue
      e ->
        Logger.debug("Error deserializing script: #{inspect(e)}")
        "Compiled script (#{byte_size(compiled)} bytes) - deserialization failed"
    end
  end
  defp analyze_compiled_script(_), do: "Invalid script format"
  
  # Analyze the decoded script operations to build a human-readable description
  defp analyze_script_operations(ops) do
    elements = ops
    |> Enum.map(&describe_operation/1)
    |> Enum.reject(&is_nil/1)
    |> Enum.uniq()
    
    if length(elements) > 0 do
      "Elements: " <> Enum.join(elements, ", ")
    else
      "No recognizable elements"
    end
  end
  
  # Convert script operations to human-readable descriptions
  defp describe_operation({:draw_text, text}) when is_binary(text), do: "text '#{text}'"
  defp describe_operation({:draw_rect, _}), do: "rectangle"
  defp describe_operation({:draw_rrect, _}), do: "rounded rectangle"
  defp describe_operation({:draw_circle, _}), do: "circle"
  defp describe_operation({:draw_ellipse, _}), do: "ellipse"
  defp describe_operation({:draw_line, _}), do: "line"
  defp describe_operation({:draw_triangle, _}), do: "triangle"
  defp describe_operation({:draw_quad, _}), do: "quad"
  defp describe_operation({:draw_arc, _}), do: "arc"
  defp describe_operation({:draw_sector, _}), do: "sector"
  defp describe_operation({:fill_color, color}), do: "fill color #{inspect(color)}"
  defp describe_operation({:stroke_color, color}), do: "stroke color #{inspect(color)}"
  defp describe_operation({:script, name}), do: "subscript '#{name}'"
  defp describe_operation(_), do: nil
  
  defp build_summary_flamelex_description(flamelex_desc, script_data, viewport_state, viewport_scripts) do
    # First, try to get a clear picture from the script data
    visual_description = extract_visual_description(script_data, viewport_scripts)
    
    parts = []
    
    # Add visual description if we have one
    parts = if visual_description != "" do
      [
        "🖼️ What I can see:",
        visual_description,
        ""
      ]
    else
      []
    end
    
    # Add Flamelex introspection if available
    parts = parts ++ if flamelex_desc do
      [
        "🎨 Flamelex Scene Description:",
        flamelex_desc[:scene_description] || "No scene description available",
        "",
        "📜 Latest Script:",
        flamelex_desc[:script_summary] || "No script summary available"
      ]
    else
      ["⚠️  Flamelex introspection not available"]
    end
    
    # Add viewport script analysis
    parts = if viewport_scripts do
      parts ++ [
        "",
        "📊 Viewport Scripts:",
        "- Total scripts: #{viewport_scripts[:script_count]}",
        "- Scripts: #{viewport_scripts[:scripts] |> Enum.take(3) |> Enum.map(fn s -> "\n  • #{s.id}: #{s.preview}" end) |> Enum.join()}"
      ]
    else
      parts
    end
    
    # Add script stats if available
    parts = if flamelex_desc && flamelex_desc[:script_stats] do
      stats = flamelex_desc[:script_stats]
      parts ++ [
        "",
        "📈 Script Statistics:",
        "- Scripts processed: #{stats[:script_count] || stats[:total_scripts] || 0}",
        "- Total size: #{stats[:total_bytes] || stats[:total_size] || 0} bytes"
      ]
    else
      parts
    end
    
    Enum.join(parts, "\n")
  end
  
  # Extract a visual description from script data
  defp extract_visual_description(script_data, viewport_scripts) do
    elements = []
    
    # Try to extract from script_data
    elements = case script_data do
      %{scripts: scripts} when is_list(scripts) ->
        scripts
        |> Enum.flat_map(fn %{script_preview: preview} ->
          extract_elements_from_preview(preview)
        end)
        |> Enum.uniq()
      _ -> []
    end
    
    # Also try viewport_scripts
    elements = elements ++ case viewport_scripts do
      %{scripts: scripts} when is_list(scripts) ->
        scripts
        |> Enum.flat_map(fn %{preview: preview} ->
          extract_elements_from_preview(preview)
        end)
        |> Enum.uniq()
      _ -> []
    end
    
    if length(elements) > 0 do
      "I can see: " <> Enum.join(Enum.uniq(elements), ", ")
    else
      ""
    end
  end
  
  defp extract_elements_from_preview(preview) when is_binary(preview) do
    # Extract meaningful elements from the preview text
    cond do
      String.contains?(preview, "Elements:") ->
        # Already processed, extract the elements
        preview
        |> String.split("Elements: ")
        |> List.last()
        |> String.split(", ")
        |> Enum.map(&String.trim/1)
      String.contains?(preview, "text '") ->
        # Extract text elements
        Regex.scan(~r/text '([^']+)'/, preview)
        |> Enum.map(fn [_, text] -> "text '#{text}'" end)
      true ->
        []
    end
  end
  defp extract_elements_from_preview(_), do: []
  
  defp build_detailed_flamelex_description(flamelex_desc, script_data, viewport_state, viewport_scripts) do
    # Similar to summary but with more detail
    build_summary_flamelex_description(flamelex_desc, script_data, viewport_state, viewport_scripts)
  end

  defp build_summary_description(scene_info, _viewport, script_data \\ nil, viewport_state \\ nil) do
    # Build visual description from script data
    visual_description = case script_data do
      %{scripts: scripts} when is_list(scripts) ->
        build_visual_summary_from_scripts(scripts)
      _ ->
        nil
    end
    
    if visual_description do
      visual_description
    else
      # Fallback to scene analysis
      scene_count = length(scene_info[:scenes] || [])
      
      # Count scenes that responded successfully vs those with actual graph data
      responding_scenes = scene_info[:scene_graphs]
      |> Enum.filter(fn sg -> Map.has_key?(sg, :graph) end)
      |> length()
      
      scenes_with_graph_data = scene_info[:scene_graphs]
      |> Enum.filter(fn sg -> 
        case Map.get(sg, :graph) do
          %{graph: graph} when not is_nil(graph) -> true
          %{graphs: graphs} when not is_nil(graphs) -> true
          _ -> false
        end
      end)
      |> length()
      
      # Build script data description
      script_description = case script_data do
        %{scripts: scripts} when is_list(scripts) ->
          "\n\n📜 Compiled Scripts (What's Actually Rendered):\n" <>
          (scripts
          |> Enum.take(3)
          |> Enum.map(fn %{name: name, script_preview: preview} ->
            "\nScript: #{inspect(name)}\n#{preview}"
          end)
          |> Enum.join("\n"))
          
        %{error: error} ->
          "\n\n⚠️  Script Data: #{error}"
          
        _ ->
          ""
      end
      
      # Show detailed breakdown of scene responses
      scene_breakdown = scene_info[:scene_graphs]
      |> Enum.take(5)  # Show first 5 scenes
      |> Enum.map(fn scene_graph ->
        if Map.has_key?(scene_graph, :graph) do
          graph_info = scene_graph[:graph]
          module_name = graph_info[:module] |> inspect() |> String.split(".") |> List.last()
          
          case {Map.get(graph_info, :graph), Map.get(graph_info, :graphs)} do
            {nil, nil} -> "  - #{module_name}: Responds but no graph in assigns"
            {graph, _} when not is_nil(graph) -> "  - #{module_name}: Has graph data ✓"
            {_, graphs} when not is_nil(graphs) -> "  - #{module_name}: Has graphs data ✓"
          end
        else
          "  - Scene #{inspect(scene_graph[:pid])}: #{scene_graph[:error]}"
        end
      end)
      |> Enum.join("\n")
      
      more_scenes = if scene_count > 5, do: "\n  ... and #{scene_count - 5} more scenes", else: ""
      
      """
      Scenic Application Status:
      - Viewport: #{inspect(scene_info[:viewport_name] || scene_info[:viewport_pid])}
      - Total Scenes Found: #{scene_count}
      - Scenes Responding: #{responding_scenes}
      - Scenes with Graph Data: #{scenes_with_graph_data}
      - Status: Running
      
      Scene Analysis (first 5):
      #{scene_breakdown}#{more_scenes}
      #{script_description}
      """
    end
  end
  
  # Build a visual summary from the script data
  defp build_visual_summary_from_scripts(scripts) do
    # Parse all scripts and build a comprehensive view
    all_elements = scripts
    |> Enum.map(fn script ->
      case script do
        %{script_preview: preview} -> {script.name, preview}
        _ -> nil
      end
    end)
    |> Enum.reject(&is_nil/1)
    
    # Build the description
    parts = ["🖼️ Visual Feedback - What I can see on screen:\n"]
    
    # Add each script's description
    parts = parts ++ Enum.map(all_elements, fn {name, preview} ->
      "• #{humanize_script_name(name)}: #{preview}"
    end)
    
    # Add summary
    parts = parts ++ ["\n📊 Total elements: #{length(scripts)} scripts rendering the interface"]
    
    Enum.join(parts, "\n")
  end
  
  # Convert script names to human-readable descriptions
  defp humanize_script_name(name) do
    cond do
      name == "_root_" -> "Root viewport"
      name == "_main_" -> "Main scene"
      String.contains?(name, "Layer") -> "UI Layer"
      String.contains?(name, "BufferPane") -> "Text buffer"
      String.contains?(name, "Caret") -> "Cursor"
      String.contains?(name, "Kommander") -> "Command bar"
      String.contains?(name, "Renseijin") -> "Background"
      true -> "Component"
    end
  end

  defp build_detailed_description(scene_info, _viewport, script_data \\ nil, viewport_state \\ nil) do
    scene_details = scene_info[:scene_graphs]
    |> Enum.map(fn scene_graph ->
      if Map.has_key?(scene_graph, :graph) do
        graph_info = scene_graph[:graph]
        """
        - Scene PID: #{inspect(scene_graph[:pid])}
          Module: #{inspect(graph_info[:module])}
          ID: #{inspect(graph_info[:id])}
          Graph: #{inspect(Map.get(graph_info, :graph))}
          Assigns Keys: #{inspect(graph_info[:assigns_keys])}
        """
      else
        "  - Scene PID: #{inspect(scene_graph[:pid])} - Error: #{scene_graph[:error]}"
      end
    end)
    |> Enum.join("\n")
    
    """
    Scenic Application Detailed Status:
    - Viewport: #{inspect(scene_info[:viewport_name] || scene_info[:viewport_pid])}
    - Active Scenes: #{length(scene_info[:scenes] || [])}
    
    Scene Details:
    #{scene_details}
    
    Note: Scenes now expose their graphs via the default handle_call(:get_graph, ...)
    implementation in Scenic.Scene. Individual scenes can override this to provide
    more detailed graph information.
    """
  end

  defp handle_send_keys(%{"text" => text} = command) when is_binary(text) do
    viewport = find_scenic_viewport()
    
    if viewport do
      modifiers = parse_modifiers(command["modifiers"] || [])
      
      Logger.info("Sending text '#{text}' to viewport #{inspect(viewport)}")
      
      # Send each character as a key event
      String.graphemes(text)
      |> Enum.each(fn char ->
        key_atom = normalize_key_name(char)
        key_event = {:key, {key_atom, 1, modifiers}}  # 1 = key_pressed
        Logger.debug("Sending key event: #{inspect(key_event)}")
        send_input_to_viewport(viewport, key_event)
        
        # Small delay between keystrokes for better reliability
        Process.sleep(10)
      end)
      
      %{status: "ok", message: "Sent text: #{text}", viewport: inspect(viewport)}
    else
      %{error: "No Scenic viewport found", available_viewports: list_scenic_viewports()}
    end
  end

  defp handle_send_keys(%{"key" => key} = command) when is_binary(key) do
    viewport = find_scenic_viewport()
    
    if viewport do
      modifiers = parse_modifiers(command["modifiers"] || [])
      key_atom = normalize_key_name(key)
      
      key_event = {:key, {key_atom, 1, modifiers}}  # 1 = key_pressed
      Logger.info("Sending key '#{key}' as #{inspect(key_atom)} to viewport #{inspect(viewport)}")
      Logger.debug("Key event format: #{inspect(key_event)}")
      
      send_input_to_viewport(viewport, key_event)
      
      %{status: "ok", message: "Sent key: #{key}", key_atom: key_atom, viewport: inspect(viewport)}
    else
      %{error: "No Scenic viewport found", available_viewports: list_scenic_viewports()}
    end
  end

  defp handle_send_keys(_command) do
    %{error: "Invalid send_keys command - must provide either 'text' or 'key'"}
  end

  defp handle_mouse_move(%{"x" => x, "y" => y}) do
    viewport = find_scenic_viewport()
    
    if viewport do
      mouse_event = {:cursor_pos, {x, y}}
      Logger.info("Sending mouse move to (#{x}, #{y}) to viewport #{inspect(viewport)}")
      Logger.debug("Mouse event format: #{inspect(mouse_event)}")
      
      send_input_to_viewport(viewport, mouse_event)
      
      %{status: "ok", message: "Mouse moved to (#{x}, #{y})", viewport: inspect(viewport)}
    else
      %{error: "No Scenic viewport found", available_viewports: list_scenic_viewports()}
    end
  end

  defp handle_mouse_move(_command) do
    %{error: "Invalid mouse_move command - must provide 'x' and 'y' coordinates"}
  end

  defp handle_mouse_click(%{"x" => x, "y" => y} = command) do
    viewport = find_scenic_viewport()
    
    if viewport do
      button = normalize_button_name(command["button"] || "left")
      
      # Send mouse move first, then click
      mouse_move = {:cursor_pos, {x, y}}
      mouse_click = {:cursor_button, {button, 1, []}}  # 1 = pressed
      
      Logger.info("Sending mouse click at (#{x}, #{y}) with #{button} button")
      Logger.debug("Mouse move event: #{inspect(mouse_move)}")
      Logger.debug("Mouse click event: #{inspect(mouse_click)}")
      
      send_input_to_viewport(viewport, mouse_move)
      Process.sleep(10)  # Small delay
      send_input_to_viewport(viewport, mouse_click)
      
      %{status: "ok", message: "Mouse clicked at (#{x}, #{y}) with #{button} button", viewport: inspect(viewport)}
    else
      %{error: "No Scenic viewport found", available_viewports: list_scenic_viewports()}
    end
  end

  defp handle_mouse_click(_command) do
    %{error: "Invalid mouse_click command - must provide 'x' and 'y' coordinates"}
  end

  # Normalize button names
  defp normalize_button_name(button) do
    case String.downcase(button) do
      "left" -> :cursor_button_left
      "right" -> :cursor_button_right
      "middle" -> :cursor_button_middle
      other -> String.to_atom("cursor_button_" <> other)
    end
  end

  # Normalize key names to match Scenic's expectations
  defp normalize_key_name(key) do
    case String.downcase(key) do
      "enter" -> :key_enter
      "return" -> :key_enter
      "escape" -> :key_escape
      "esc" -> :key_escape
      "tab" -> :key_tab
      "backspace" -> :key_backspace
      "delete" -> :key_delete
      "space" -> :key_space
      "up" -> :key_up
      "down" -> :key_down
      "left" -> :key_left
      "right" -> :key_right
      "home" -> :key_home
      "end" -> :key_end
      "page_up" -> :key_page_up
      "pageup" -> :key_page_up
      "page_down" -> :key_page_down
      "pagedown" -> :key_page_down
      "f1" -> :key_f1
      "f2" -> :key_f2
      "f3" -> :key_f3
      "f4" -> :key_f4
      "f5" -> :key_f5
      "f6" -> :key_f6
      "f7" -> :key_f7
      "f8" -> :key_f8
      "f9" -> :key_f9
      "f10" -> :key_f10
      "f11" -> :key_f11
      "f12" -> :key_f12
      # For any other key, try to convert to atom
      other -> String.to_atom("key_" <> other)
    end
  end



  defp parse_modifiers(modifiers) when is_list(modifiers) do
    Enum.map(modifiers, fn mod ->
      case String.downcase(mod) do
        "ctrl" -> :ctrl
        "shift" -> :shift
        "alt" -> :alt
        "cmd" -> :cmd
        "meta" -> :meta
        other -> String.to_atom(other)
      end
    end)
  end

  defp parse_modifiers(_), do: []

  # Generic Scenic viewport discovery
  defp find_scenic_viewport do
    # Try multiple strategies to find a Scenic viewport
    find_by_registered_name() ||
    find_by_process_dictionary() ||
    find_by_scenic_supervisor()
  end

  # Strategy 1: Look for common viewport names
  defp find_by_registered_name do
    common_names = [
      :main_viewport,
      :viewport,
      :scenic_viewport
    ]
    
    Enum.find_value(common_names, fn name ->
      case Process.whereis(name) do
        nil -> nil
        pid -> pid
      end
    end)
  end

  # Strategy 2: Look through process dictionary for Scenic-related processes
  defp find_by_process_dictionary do
    Process.list()
    |> Enum.find(fn pid ->
      case Process.info(pid, :registered_name) do
        {:registered_name, name} when is_atom(name) ->
          name_str = Atom.to_string(name)
          String.contains?(name_str, "viewport") or String.contains?(name_str, "Viewport")
        _ ->
          false
      end
    end)
  end

  # Strategy 3: Look for processes under Scenic supervisor
  defp find_by_scenic_supervisor do
    try do
      # Look for any process that might be a Scenic viewport
      Process.list()
      |> Enum.find(fn pid ->
        case Process.info(pid, :dictionary) do
          {:dictionary, dict} ->
            Enum.any?(dict, fn {key, _value} ->
              key_str = inspect(key)
              String.contains?(key_str, "scenic") or String.contains?(key_str, "viewport")
            end)
          _ ->
            false
        end
      end)
    rescue
      _ -> nil
    end
  end

  # List all potential Scenic viewports for debugging
  defp list_scenic_viewports do
    registered_processes = Process.registered()
    |> Enum.filter(fn name ->
      name_str = Atom.to_string(name)
      String.contains?(name_str, "viewport") or 
      String.contains?(name_str, "Viewport") or
      String.contains?(name_str, "scenic") or
      String.contains?(name_str, "Scenic")
    end)

    %{
      registered_scenic_processes: registered_processes,
      total_processes: length(Process.list()),
      found_viewport: find_scenic_viewport() != nil
    }
  end

  # Generic input sending that works with any Scenic viewport
  defp send_input_to_viewport(viewport_pid, event) when is_pid(viewport_pid) do
    Logger.debug("Injecting input event via ViewPort: #{inspect(event)}")
    
    # Use proper Scenic ViewPort input routing
    send_via_viewport(viewport_pid, event)
  end
  
  defp send_input_to_viewport(nil, event) do
    Logger.error("❌ No viewport found for event: #{inspect(event)}")
    {:error, :no_viewport}
  end
  
  # Send event via direct message to viewport - simpler approach
  defp send_via_viewport(viewport_pid, event) do
    try do
      # Send the event directly to the viewport process
      # The viewport will handle validation and routing
      send(viewport_pid, {:input, event})
      Logger.info("✅ Sent event to viewport: #{inspect(event)}")
      :ok
    rescue
      e ->
        Logger.error("❌ Exception while sending input to viewport: #{inspect(e)}")
        Logger.error("❌ Event that caused exception: #{inspect(event)}")
        {:error, e}
    end
  end
end
